{
  "name": "postcss-extend",
  "author": {
    "name": "Travis Palmer",
    "email": "hofnug@gmail.com"
  },
  "license": "MIT",
  "version": "1.0.1",
  "description": "As close to cssnext @extend as possible for PostCSS",
  "homepage": "https://github.com/travco/postcss-extend",
  "repository": {
    "type": "git",
    "url": "https://github.com/travco/postcss-extend.git"
  },
  "keywords": [
    "css",
    "postcss",
    "postcss-plugin",
    "mixin",
    "clone",
    "extend"
  ],
  "files": [
    "index.js",
    "LICENSE",
    "README.md",
    "CHANGELOG.md"
  ],
  "main": "index.js",
  "scripts": {
    "lint": "eslint index.js test/index.js",
    "test": "rm -f test/debugout.txt && npm run lint && tape test"
  },
  "dependencies": {
    "postcss": "^5.0.4"
  },
  "devDependencies": {
    "eslint": "0.18.0",
    "tape": "4.0.0"
  },
  "readme": "# postcss-extend [![Build Status](https://travis-ci.org/travco/postcss-extend.svg?branch=master)](https://travis-ci.org/travco/postcss-extend)\r\n\r\n**A [PostCSS](https://github.com/postcss/postcss) plugin that tries to minimize the number of repeat selectors and rules you write in CSS.**\r\n\r\n\r\n\r\nUse this plugin to:\r\n- Define a \"silent\" extendable selector — a \"placeholder selector\" — to which you can (from anywhere in the doc) add concrete selectors from other rule sets.\r\n- Add concrete selectors from one rule (containing the `@extend`) to all rule sets with the selector specified (or a subclass of the one specified).\r\n- Pull in declarations in rulesets (most) anywhere in the doc (by a selector) from within `@media` statements (semi-safely)\r\n- Extend existing media-conscious rulesets, even if some of them are within `@media` statements.\r\n\r\n\r\n[Installation](https://github.com/travco/postcss-extend#installation) | [Usage](https://github.com/travco/postcss-extend#usage) | [Getting it Working](https://github.com/travco/postcss-extend#getting-it-working-with-postcss) | [Quirks](https://github.com/travco/postcss-extend#quirks)\r\n--- | --- | --- | ---\r\n\r\n\r\nThe logical statement of *this* `@extend` is to \"allow my parent rule to use the declarations of what I extend\".\r\nThe functionality is intended to somewhat mirror Sass's `@extend` with `%` placeholders (a.k.a. \"silent classes\") and real rules.\r\nUnlike Sass's `@extend`, however, this plugin (among other things) *does not allow you to extend into selector sequences*: i.e. if you want to `@extend a`, it will not go off and try to extend:\r\n```css\r\n#admin .tabbar a {\r\n  font-weight: bold;\r\n}\r\n```\r\n*Nor* will trying to `@extend a:hover` match:\r\n```css\r\n.comment a.user:hover {\r\n  color: red;\r\n}\r\n```\r\n\r\nIt **will** however, try to extend selector sequences with the base-piece to work with, i.e. trying to `@extend .never` will match:\r\n```css\r\n.never li:first {\r\n  color: red;\r\n}\r\n/*or*/\r\n.never.ever {\r\ncolor: blue;\r\n}\r\n```\r\n\r\nArguably, these limitations make this plugin both less dangerous than SASS's `@extend`, and enforce more (obviously-)predictable behaviors. However, many of SASS `@extend`'s other behaviors have been kept, or altered in such a way to allow ease of use, but not necessarily the same level of strict logical extension.\r\nIn regards to the concerns people have with Sass's `@extend`, and the problems that can arise from its use, many do not apply to this stripped-out version. However, it is by no means foolproof, and Smart Sass users often recommend to only ever `@extend` placeholders (cf. [Harry Robert](http://csswizardry.com/2014/01/extending-silent-classes-in-sass/) and [Hugo Giraudel](http://sass-guidelin.es/#extend)): *with this plugin, that recommendation is not enforced, but syntactically set apart*.\r\n\r\n**`postcss-extend` is compatible with PostCSS v5.0+.**\r\n\r\n> **A Note on \"mixins\" & \"extends\"**: Mixins copy declarations from an abstract definition into a concrete rule set. These `@extend`s (normally) clone a concrete rule set's selector(s) and add them to an abstract placeholder selector, or another existing rule. *This* plugin enables extends. If you would like to use mixins, as well — or instead — have a look at [`postcss-mixins`](https://github.com/postcss/postcss-mixins).\r\n\r\n## Installation\r\n```\r\nnpm install postcss-extend --save\r\n```\r\n\r\n\r\n**Public Service Announcement**: Because of [an issue with `postcss-nested`](https://github.com/postcss/postcss-nested/issues/11), if you are trying to use *both* `postcss-nested` and this plugin, you need to *use this plugin first*.\r\n\r\n\r\n## Usage\r\n\r\n- [Defining Placeholders](https://github.com/travco/postcss-extend#defining-placeholders)\r\n  - [The '%' placeholder](https://github.com/travco/postcss-extend#the--silent-placeholder)\r\n- [Extending Rules or Placeholders](https://github.com/travco/postcss-extend#extending-rules-or-placeholders)\r\n  - [Extending Sub Classes and Sub Elements](https://github.com/travco/postcss-extend#extending-sub-classes-and-sub-elements)\r\n  - [Extending with @media](https://github.com/travco/postcss-extend#extending-with-media)\r\n    - [Simple declaration-pulling](https://github.com/travco/postcss-extend#simple-declaration-pulling)\r\n    - [External Sub classes](https://github.com/travco/postcss-extend#external-sub-classes)\r\n    - [Extending something inside @media (on the outside looking in)](https://github.com/travco/postcss-extend#extending-something-inside-media-on-the-outside-looking-in)\r\n    - [Extending something in an @media while inside an @media](https://github.com/travco/postcss-extend#extending-something-in-an-media-while-inside-an-media)\r\n- [Chaining `@extend`s, or Extension-Recursion](https://github.com/travco/postcss-extend#chaining-extends-or-extension-recursion)\r\n\r\n### Defining Placeholders\r\n\r\nWith `@define-placeholder`, you associate a rule set with a placeholder selector, which you will later extend with concrete selectors. It (and its other aliases) can only be extended if it's already been declared in the document, and *cannot be extended-out-of*.\r\n\r\nYou can also use its aliases: `@define-extend` or `@extend-define`.\r\n\r\n```css\r\n@define-placeholder simple-list {\r\n  list-style-type: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n/* or @define-extend simple list {...} */\r\n/* or @extend-define list {...} */\r\n```\r\n\r\n`@define-placeholder` at-rules, and the placeholder names (e.g. `simple-list`, above), will be removed entirely from the generated CSS, replaced by the selectors you've added via `@extend` (see example above).\r\n\r\n##### The \"%\" (silent) placeholder\r\n\r\nThe \"%\" placeholder acts in exactly the same way as `@define-placeholder` and its aliases, with three exceptions. One, that it doesn't need to be declared before it is extended. Two, you can extend out of it (thus extending anything that extends the placeholder, or nothing if the placeholder isn't referenced). Three, it needs to be specifically targeted in the extend, for example: `@extend %simple-list`.\r\n\r\n(`@define-placeholder`'s limitations are an originally unintended feature, kept for its possible usefulness as a stricter, more controlled method of extending).\r\n\r\nAdditionally, all definitions will log a warning if they go unused, and should only contain declarations and comments: no statements (violations will also log warnings).\r\n\r\n### Extending Rules or Placeholders\r\n\r\nUse the at-rule `@extend` within a rule set to add that rule set's selector(s) to a placeholder (which was defined via `@define-placeholder`).\r\n\r\nYou can also use its alias `@define-extend'.\r\n\r\n```css\r\n.list-i-want-to-be-simple {\r\n  @extend simple-list;\r\n  font-size: 40em;\r\n}\r\n```\r\nRules and placeholders are extended in much the same fashion; the only real difference is that placeholders can be named most anything, whereas rules need to be extended via the same syntax in the css. For example, to extend a 'foo' class it'd be `@extend .foo`\r\n\r\nThere is only one overarching `@extend` guideline to obey: `@extend` must **not** occur at the root level, it only can be used inside rule sets.\r\n\r\n#### Extending Sub Classes and Sub Elements\r\n\r\nWhenever extending a rule or placeholder, you are also automatically trying to extend any subclasses or elements that have *exactly* what you selected (before a space, `.`, `:`, or `#`). For example:\r\n```css\r\n.potato {\r\n  color: white;\r\n}\r\n\r\n.potato:first-child,\r\n.potato a::after {\r\n  background: brown;\r\n}\r\n\r\n#superfun {\r\n  @extend .potato;\r\n}\r\n```\r\nResolves to:\r\n```css\r\n.potato, #superfun {\r\n  color: white;\r\n}\r\n\r\n.potato:first-child, .potato a::after, #superfun:first-child, #superfun a::after {\r\n  background: brown;\r\n}\r\n```\r\nMake note that `#superfun` deletes itself, because otherwise it would have been empty brackets.\r\n\r\nYou also can still specifically extend subclasses by-themselves by calling them out explicitly.\r\nIf (in the above example) you wanted to only get `background:brown` instead of everything having to do with `.potato`, you could just use `@extend .potato:first-child;`.\r\n\r\n#### Extending with `@media`\r\n\r\nThe bridging behavior of this plugin is by far its most dangerous, despite the steps to keep it relatively sane. Be mindful.\r\nThe logical statement of *this* `@extend` is to \"allow my parent rule to use the declarations of what I extend.\" Thus, when within an @media rule, its behavior takes on the contingency of the rule, and instead of tacking on its parent's selectors to rules it extends (thus using their declarations), it directly brings in the declarations.\r\n\r\n##### Simple declaration pulling\r\n\r\nTrying to extend a rule outside an `@media` from the inside is fairly straightforward. For example:\r\n```css\r\n.potato {\r\n  color: white;\r\n  outline: brown;\r\n  font-family: sans-serif;\r\n}\r\n\r\n@media (width > 600px) {\r\n  .potato:first {\r\n    float: center;\r\n  }\r\n\r\n  .spud {\r\n    @extend .potato;\r\n    color: red;\r\n    font-size: 4em;\r\n  }\r\n}\r\n```\r\nResolves to:\r\n```css\r\n.potato {\r\n  color: white;\r\n  outline: brown;\r\n  font-family: sans-serif;\r\n}\r\n\r\n@media (width > 600px) {\r\n  .potato:first, .spud:first {\r\n    float: center;\r\n  }\r\n\r\n  .spud {\r\n    color: red;\r\n    font-size: 4em;\r\n    outline: brown;\r\n    font-family: sans-serif;\r\n  }\r\n}\r\n```\r\nNotice how `.spud` only takes in declarations from `.potato` that it doesn't already have. Extending will never override declarations already present while copying. Additionally, notice how `.spud` extends `.potato`'s pseudo-class (`:first`) inside the media scope by tacking onto the target rule, just like before. That's because it is scope-conscious (especially while in an `@media`).\r\n\r\n##### External Sub classes\r\n\r\nSo what does it do when subclasses of the extended rule are also outside `@media`?\r\n```css\r\n.potato {\r\n  float: left;\r\n}\r\n\r\n.potato:first, .potato ul:first-child {\r\n  float: right;\r\n}\r\n\r\n@media (width > 600px) {\r\n  .spud {\r\n    @extend .potato;\r\n    font-weight: bold;\r\n    color: red;\r\n  }\r\n\r\n  .spud:first {\r\n    background: purple;\r\n  }\r\n}\r\n```\r\nResolves to:\r\n```css\r\n.potato {\r\n  float: left;\r\n}\r\n\r\n.potato:first, .potato ul:first-child {\r\n  float: right;\r\n}\r\n\r\n@media (width > 600px) {\r\n  .spud {\r\n    font-weight: bold;\r\n    color: red;\r\n    float: left;\r\n  }\r\n  .spud ul:first-child {\r\n    float: right;\r\n  }\r\n\r\n  .spud:first {\r\n    background: purple;\r\n    float: right;\r\n  }\r\n}\r\n```\r\nFirst let's notice that the sub class `.spud ul:first-child` (which wasn't within `@media` originally) is created with a copy of `.potato ul:first-child`'s declaration. Meanwhile, `.spud:first` was already within the `@media` rule, and it took on the extra declaration. If there is a rule within the `@media` with exactly the same selectors as what it would create, it will just pull in declarations. Keep in mind, the same ideas apply here while \"pulling in\" declarations: it copies, but won't replace.\r\n\r\n##### Extending something inside `@media` (on the outside looking in)\r\n\r\nSo what if you want to extend something that's within an `@media` from the root? It's actually fairly straightforward when you think about what that means.\r\n```css\r\n@media (width > 600px) {\r\n  .spud {\r\n    font-weight: bold;\r\n    color: red;\r\n  }\r\n  .spud:first-child {\r\n    background: purple;\r\n  }\r\n}\r\n\r\n.sputnik {\r\n  @extend .spud;\r\n  font-weight: normal;\r\n  font-style: italic;\r\n}\r\n```\r\nResolves to:\r\n```css\r\n@media (width > 600px) {\r\n  .spud, .sputnik {\r\n    font-weight: bold;\r\n    color: red;\r\n  }\r\n  .spud:first-child, .sputnik:first-child {\r\n    background: purple;\r\n  }\r\n}\r\n\r\n.sputnik {\r\n  font-weight: normal;\r\n  font-style: italic;\r\n}\r\n```\r\nExtending from the root, just like before, just tacks on selectors onto target rules, even into the `@media`. This stays true to the logic of *this* version of `@extend` because it's maintaining the conditionality of the declarations within `@media`.\r\n\r\n##### Extending something in an `@media` while inside an `@media`\r\n\r\n**Don't**. It's currently directly-disallowed in code to prevent unexpected things from happening, and will throw an error to warn you. The current expectation is that the only time the majority of users would do this is when making a mistake. That expectation remains unless someone can present a solution and a logical way of handling this (not in the native CSS parser) that is also a realistic common-use case.\r\n\r\n#### Chaining `@extend`s, or extension-recursion\r\n\r\nDefinitely one of the more powerful features of SASS's `@extend` is here too. It does, however, come with a slight caveat that it is order-agnostic, meaning that it doesn't enforce order by only extending that which came above it. It just goes.\r\n```css\r\n.charlie {\r\n  @extend .delta;\r\n  font-weight: bold;\r\n}\r\n.alpha {\r\n  @extend .bravo;\r\n  color: red;\r\n}\r\n.bravo {\r\n  @extend .charlie;\r\n  background: blue;\r\n}\r\n.delta {\r\n  color: green;\r\n  background: gray;\r\n}\r\n```\r\nResolves to:\r\n```css\r\n.charlie, .bravo, .alpha {\r\n  font-weight: bold;\r\n}\r\n.alpha {\r\n  color: red;\r\n}\r\n.bravo, .alpha {\r\n  background: blue;\r\n}\r\n.delta, .charlie, .bravo, .alpha {\r\n  color: green;\r\n  background: gray;\r\n}\r\n```\r\nDoesn't that take a lot of computation to do though? Well, not really since it's not \"true\" recursion. Since we're tacking on selectors, every rule is a living record of everything that has extended it, and if we're not tacking on selectors, we're copying everything we need from the other rule. Thus, in well-formed CSS we only need to go through the CSS doc once, top to bottom.\r\n\r\nIn anti-pattern CSS (extending things yet to be declared), it will handle `@extend` recursively, but only if the extended target has unresolved `@extend` rules in it (thus, slowing down processing, but keeping it working as expected). As a bonus, there is a built-in recursive-stack tracking that both detects infinite loops, and throws warnings (in order of least-tampered css first) for every step of the infinite loop. It also does its best to still process the CSS in the infinite loop (almost always as intended).\r\n\r\n## Getting It Working with PostCSS\r\n\r\nPlug it in just like any other [PostCSS](https://github.com/postcss/postcss) plugin. There are no frills and no options, so integration should be straightforward. For example (as a node script):\r\n\r\n```js\r\nvar fs = require('fs');\r\nvar postcss = require('postcss');\r\nvar simpleExtend = require('postcss-extend');\r\n\r\nvar inputCss = fs.readFileSync('input.css', 'utf8');\r\n\r\nvar outputCss = postcss()\r\n  .use(simpleExtend())\r\n  // or .use(simpleExtend)\r\n  .process(inputCss)\r\n  .css;\r\n\r\nconsole.log(outputCss);\r\n```\r\n\r\nOr take advantage of [any of the myriad of other ways to consume PostCSS](https://github.com/postcss/postcss#usage), and follow the plugin instructions they provide.\r\n\r\n## Quirks\r\nAs with any piece of code, it's got a few quirks. Behaviors that are not intended, and not enforced, may disappear (or be forcibly altered) with the next release, so it's useful to be aware of them.\r\n\r\n**Order of Processing** : Currently, all of the `@extend`s being processed are run in a sequential manner from the top to the bottom of the doc. This keeps things relatively snappy, but makes it so that we have to do conditional-recursion on not-yet-declared-or-extended rules. This leads to some blatant inefficiencies when processing badly formed CSS (anti-pattern CSS). So if you want to keep processing time down, write good CSS. If you're curious if what you're writing is an anti-pattern, don't worry, it will throw a warning.\r\n\r\n**Non-logical means of extension for `@media`** : As anyone who's aware of the complications discussed in the [SASS issue about extending across `@media`](https://github.com/sass/sass/issues/1050) would know. There is no way (known) of extending when `@media` rules are involved that is both 'clean and simple' and 'logically correct with how `@extend` is used elsewhere'. The way this plugin operates, and its logical meaning, is a blatant compromise so that it has both common use cases and easier implementation. While the current implementations will not change (without flags), such things as extending an `@media` from within an `@media` does nothing, this could possibly change in the future.\r\n\r\n#### 'TLDR' Contention with the `@extend` [spec](https://tabatkins.github.io/specs/css-extend-rule):\r\n\r\n- **Order of Processing/Specificity** In normal cases, the document is processed top-to-bottom; however, as a feature-fallout of the implementation, it is capable of extending in an anti-pattern (extending things yet to be declared). If what you're writing is an anti-pattern, it will throw a warning.\r\n- **Media-cross-media Inheritance** Attempting to extend a rule inside a media block from within another media block [is directly disallowed in the code](https://github.com/travco/postcss-extend#quirks) and will throw a warning.\r\n- **Silent placeholders** Includes both the stricter `@define-placeholder` and its aliases for compatibility with [simple-extend](https://github.com/davidtheclark/postcss-simple-extend), and the `%` placeholder [from the spec](https://tabatkins.github.io/specs/css-extend-rule/#placeholder). As this isn't the native parser, the placeholder will be wiped from the CSS if it goes unused (as well as throw a warning).\r\n- **Subclass inheritance** Currently doesn't log a warning for its use, as it is not stated in the spec for or against its behavior (despite it logically following). All [sub classes of an extended \"base\" class are extended](https://github.com/travco/postcss-extend#extending-sub-classes-and-sub-elements), creating subclasses for the extending class as a means of mimicking the inheritance of specific sub-class contingencies (like `:active`)\r\n- **\"Whiff\" extension** trying to extend something that doesn't exist will log an error, and like everything else, remove the `@extend` rule.\r\n\r\n\r\n##### Originally a fork of davidtheclark's [postcss-simple-extend](https://github.com/davidtheclark/postcss-simple-extend) (extended) by way of the included [MIT License](https://github.com/travco/postcss-extend/blob/master/LICENSE)\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/travco/postcss-extend/issues"
  },
  "_id": "postcss-extend@1.0.1",
  "_from": "postcss-extend@^1.0.1"
}
